## 리밸런싱
컨슈머 그룹으로 이루어진 컨슈머들 중 일부 컨슈머에 장애가 발생하면, 정상적인 컨슈머가 파티션을 재할당하게 된다.
문제가 발생한 컨슈머에 할당된 파티션에는 더 이상 데이터를 처리하지 못하므로 리밸런싱 과정에 대한 코드가 비즈니스 코드로 작성되어야 하는데,
데이터 처리 중에 발생한 리밸런싱에 대응하는 코드를 아래의 상황에서부터 생각해볼 수 있다.

1. 컨슈머가 추가되는 상황
2. 컨슈머가 제외되는 상황

이처럼 가용성을 높이면서도 안정적인 운영을 도와주는 리밸런싱은 유용하지만 자주 일어나서는 안 된다.
파티션의 소유권을 재할당하는 과정에서 해당 컨슈머 그룹의 컨슈머들이 토픽의 데이터를 읽을 수 없기 때문이다.

## Commit

- 오프셋 커밋: 컨슈머 애플리케이션에서 명시적, 비명시적으로 수행할 수 있다.
- 비명시
    - enable.auto.commit=true: poll 메서드가 수행될 때 일정 간격마다 오프셋을 커밋
    - auto.commit.interval.ms: 설정된 값 이상이 지났을 때 그 시점까지 읽은 레코드의 오프셋을 커밋

          _consumer_offsets: 특정 토픽의 파티션을 어떤 컨슈머 그룹이 몇 번째 가져갔는지
          카프카 브로커 내부에서 사용되는 내부 토픽에 기록
- 명시
    - commitSync() 메서드를 호출: poll 메서드를 통해 반환된 레코드의 가장 마지막 오프셋을 기준으로 커밋
        - 커밋이 정상적으로 처리되었는지 응답하기까지 시간이 걸릴 수 있다. 커밋 요청 응답 시간이 오래걸린다면 데이터 처리량이 줄어들기 때문이다.
    - commitAsnc() 메서드를 호출: 커밋 요청이 실패했을 경우 현재 처리 중인 데이터의 순서를 보장하지 않으며 데이터의 중복 문제가 발생할 수 있다.